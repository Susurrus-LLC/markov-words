{"version":3,"sources":["components/page/page.module.sass","components/page/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Page","useState","input","setInput","changed","setChanged","min","setMin","max","setMax","num","setNum","err","setErr","text","setText","starters","setStarters","terminals","setTerminals","dictionary","setDictionary","output","setOutput","useEffect","toLowerCase","split","filter","word","length","choose","arr","Math","floor","random","build","i","concat","slice","join","j","hasOwnProperty","generate","getLookup","letter","next","lookup","push","className","styles","main","placeholder","value","onChange","e","target","id","type","defaultValue","toString","onClick","results","errored","makeWords","App","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","ReactDOM","render","document","getElementById","URL","process","href","origin","addEventListener","fetch","response","contentType","headers","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.1af2b187.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"text\":\"page_text__XIgGK\"};","import React, { useState, useEffect } from 'react'\r\nimport styles from './page.module.sass'\r\n\r\nconst Page: React.FC = () => {\r\n  interface Terminals {\r\n    [propName: string]: boolean\r\n  }\r\n\r\n  interface Dictionary {\r\n    [propName: string]: string[]\r\n  }\r\n\r\n  const [input, setInput] = useState('')\r\n  const [changed, setChanged] = useState(false)\r\n  const [min, setMin] = useState(3)\r\n  const [max, setMax] = useState(8)\r\n  const [num, setNum] = useState(50)\r\n  const [err, setErr] = useState('')\r\n  const [text, setText] = useState([''])\r\n  const [starters, setStarters] = useState([''])\r\n  const [terminals, setTerminals] = useState<Terminals>({})\r\n  const [dictionary, setDictionary] = useState<Dictionary>({})\r\n  const [output, setOutput] = useState('')\r\n\r\n  useEffect(() => {\r\n    // split the input based on any punctuation, line breaks, or spaces\r\n    setText(\r\n      input\r\n        .toLowerCase()\r\n        .split(/[\\n .,/#!$%@^&*;:{}=\\-_`~[\\]()]/)\r\n        .filter(word => word.length > 0)\r\n    )\r\n  }, [input])\r\n\r\n  // make a random choice, given options\r\n  const choose = (arr: string[]) => arr[Math.floor(arr.length * Math.random())]\r\n\r\n  const build = (min: number) => {\r\n    // if the minimum length is greater than the maximum, display an error\r\n    if (min > max) {\r\n      setErr('Maximum length must be greater or equal to minimum length.')\r\n      return false\r\n    } else {\r\n      setErr('')\r\n    }\r\n\r\n    // if the input has changed,\r\n    if (changed) {\r\n      // build the dictionary, terminals, and starters\r\n      for (let i = 0; i < text.length; i++) {\r\n        // grab the word and split it into an array of letters\r\n        const word = text[i].split('')\r\n        // add the word-initial letter pair to the list of possible starters\r\n        setStarters(starters.concat(word.slice(0, 2).join('')))\r\n        // add the word-final letter pair to the list of possible terminals\r\n        setTerminals({\r\n          ...terminals,\r\n          [word.slice(-2).join('')]: true\r\n        })\r\n\r\n        // build the dictionary and stats\r\n        for (let j = 0; j < word.length - 1; j++) {\r\n          // add lookups for single letters\r\n          if (dictionary.hasOwnProperty(word[j])) {\r\n            // if the letter is already in the dictionary, add its following letter\r\n            setDictionary({\r\n              ...dictionary,\r\n              [word[j]]: dictionary[word[j]].concat([word[j + 1]])\r\n            })\r\n          } else {\r\n            // otherwise, add the letter and its following letter\r\n            setDictionary({\r\n              ...dictionary,\r\n              [word[j]]: [word[j + 1]]\r\n            })\r\n          }\r\n\r\n          // add lookups for paired letters after reaching the second letter\r\n          if (j > 0) {\r\n            if (dictionary.hasOwnProperty(word[j - 1] + word[j])) {\r\n              // if the letter pair is already in the dictionary, add its following letter\r\n              setDictionary({\r\n                ...dictionary,\r\n                [word[j - 1] + word[j]]: dictionary[\r\n                  word[j - 1] + word[j]\r\n                ].concat([word[j + 1]])\r\n              })\r\n            } else {\r\n              // otherwise, add the letter pair and its following letter\r\n              setDictionary({\r\n                ...dictionary,\r\n                [word[j - 1] + word[j]]: [word[j + 1]]\r\n              })\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    const generate = (min: number): string | false => {\r\n      // grab the last letter(s) of the word for lookup\r\n      const getLookup = (word: string[]) => {\r\n        return word.length < 2 ? word[word.length - 1] : word.slice(-2).join('')\r\n      }\r\n\r\n      // build words\r\n      if (text.length > 0) {\r\n        // start with starter letters\r\n        let letter = choose(starters)\r\n        let next = letter.split('')\r\n        let word = next\r\n        let lookup = getLookup(word)\r\n\r\n        while (dictionary.hasOwnProperty(lookup)) {\r\n          // choose the next letter and add it to the word\r\n          next = dictionary[lookup]\r\n          letter = choose(next)\r\n          word.push(letter)\r\n          lookup = getLookup(word)\r\n\r\n          // if the word is long enough and the current letter is a terminal, end the loop\r\n          if (word.length >= min && terminals.hasOwnProperty(lookup)) {\r\n            break\r\n          }\r\n        }\r\n\r\n        // if the word isn't long enough, try again\r\n        if (word.length < min) {\r\n          return generate(min)\r\n        } else {\r\n          return word.join('')\r\n        }\r\n      } else {\r\n        setErr('No input provided.')\r\n        return false\r\n      }\r\n    }\r\n\r\n    return generate(min)\r\n  }\r\n\r\n  const makeWords = () => {\r\n    let results = []\r\n    let errored = false\r\n\r\n    // randomize the length of the words between the min and the max\r\n    for (let i = 0; i < num; i++) {\r\n      const length = min + Math.floor((max + 1 - min) * Math.random())\r\n      results.push(build(length))\r\n    }\r\n\r\n    // if the results array includes a falsy value, it errored\r\n    for (let i = 0; i < results.length; i++) {\r\n      errored = !results[i]\r\n      break\r\n    }\r\n\r\n    if (errored) {\r\n      setOutput(err)\r\n    } else {\r\n      setOutput(results.join(' '))\r\n    }\r\n  }\r\n\r\n  return (\r\n    <main className={styles.main}>\r\n      <textarea\r\n        className={styles.text}\r\n        placeholder='Enter as many words as you can. The more the better.'\r\n        value={input}\r\n        onChange={e => {\r\n          setInput(e.target.value)\r\n          setChanged(true)\r\n        }}\r\n      />\r\n      <div>\r\n        <label>\r\n          minimum length:{' '}\r\n          <input\r\n            id='min'\r\n            type='number'\r\n            min='1'\r\n            max='10'\r\n            defaultValue={min.toString()}\r\n            value={min}\r\n            onChange={e => setMin(+e.target.value)}\r\n          />\r\n        </label>\r\n        <label>\r\n          maximum length:{' '}\r\n          <input\r\n            id='max'\r\n            type='number'\r\n            min='3'\r\n            max='20'\r\n            defaultValue={max.toString()}\r\n            value={max}\r\n            onChange={e => setMax(+e.target.value)}\r\n          />\r\n        </label>\r\n        <label>\r\n          number of words:{' '}\r\n          <input\r\n            id='num'\r\n            type='number'\r\n            min='1'\r\n            max='1000'\r\n            defaultValue={num.toString()}\r\n            value={num}\r\n            onChange={e => setNum(+e.target.value)}\r\n          />\r\n        </label>\r\n      </div>\r\n      <button\r\n        id='generate'\r\n        onClick={() => {\r\n          makeWords()\r\n          setChanged(false)\r\n        }}\r\n      >\r\n        Generate\r\n      </button>\r\n      <div className='results'>\r\n        <p className='result'>{output}</p>\r\n      </div>\r\n    </main>\r\n  )\r\n}\r\n\r\nexport default Page\r\n","import React from 'react'\nimport 'normalize.css'\nimport '@fortawesome/fontawesome-free/css/all.css'\n\nimport './App.module.sass'\n\nimport Page from './components/page'\n\nconst App: React.FC = () => {\n  return (\n    <>\n      <header className='header' />\n      <Page />\n      <footer className='footer' />\n    </>\n  )\n}\n\nexport default App\n","const isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register (config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    )\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW (swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker (swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      )\n    })\n}\n\nexport function unregister () {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister()\n    })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport './index.sass'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\nserviceWorker.register()\n"],"sourceRoot":""}