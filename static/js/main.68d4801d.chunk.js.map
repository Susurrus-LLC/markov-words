{"version":3,"sources":["components/form/form.module.sass","components/results/results.module.sass","components/page-footer/pageFooter.module.sass","components/page-header/index.tsx","components/results/index.tsx","components/form/index.tsx","components/page-footer/index.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["module","exports","Header","className","styles","header","title","Results","props","results","result","Form","useState","input","setInput","min","setMin","max","setMax","num","setNum","text","setText","starters","setStarters","startersReady","setStartersReady","terminals","setTerminals","terminalsReady","setTerminalsReady","dictionary","setDictionary","dictionaryReady","setDictionaryReady","output","setOutput","useEffect","toLowerCase","split","filter","word","length","makeWords","choose","arr","Math","floor","random","generate","getLookup","slice","join","letter","next","lookup","hasOwnProperty","push","i","newStart","newTerm","newDict","j","build","main","form","id","name","placeholder","value","onChange","e","target","options","type","onClick","preventDefault","Footer","footer","copyright","href","rel","current","Date","getFullYear","toString","years","App","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","ReactDOM","render","document","getElementById","URL","process","origin","addEventListener","fetch","response","contentType","headers","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.68d4801d.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"form\":\"form_form__1G0jk\",\"text\":\"form_text__1E_v6\",\"options\":\"form_options__3lfSz\",\"generate\":\"form_generate__1Br-P\",\"results\":\"form_results__3J2XQ\",\"num\":\"form_num__1o_QM\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"results\":\"results_results__rKSEs\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"footer\":\"pageFooter_footer__19AKf\"};","import React from 'react'\r\n\r\nimport styles from './pageHeader.module.sass'\r\n\r\nconst Header: React.FC = () => {\r\n  return (\r\n    <header className={styles.header}>\r\n      <h1 className={styles.title}>Markov Word Generator</h1>\r\n    </header>\r\n  )\r\n}\r\n\r\nexport default Header\r\n","import React from 'react'\r\n\r\nimport styles from './results.module.sass'\r\n\r\nconst Results: React.FC<{results: string}> = props => (\r\n  <div className={styles.results}>\r\n    <p className={styles.result}>{props.results}</p>\r\n  </div>\r\n)\r\n\r\nexport default Results\r\n","import React, { useState, useEffect } from 'react'\r\n\r\nimport Results from '../results'\r\n\r\nimport styles from './form.module.sass'\r\n\r\nconst Form: React.FC = () => {\r\n  interface Terminals {\r\n    [propName: string]: boolean\r\n  }\r\n\r\n  interface Dictionary {\r\n    [propName: string]: string[]\r\n  }\r\n\r\n  const [input, setInput] = useState('')\r\n  const [min, setMin] = useState(3)\r\n  const [max, setMax] = useState(10)\r\n  const [num, setNum] = useState(100)\r\n  const [text, setText] = useState<string[]>([])\r\n  const [starters, setStarters] = useState<string[]>([])\r\n  const [startersReady, setStartersReady] = useState(false)\r\n  const [terminals, setTerminals] = useState<Terminals>({})\r\n  const [terminalsReady, setTerminalsReady] = useState(false)\r\n  const [dictionary, setDictionary] = useState<Dictionary>({})\r\n  const [dictionaryReady, setDictionaryReady] = useState(false)\r\n  const [output, setOutput] = useState('')\r\n\r\n  useEffect(() => {\r\n    setText(\r\n      input\r\n        .toLowerCase() // make everything lowercase\r\n        .split(/[\\n .\"“”‘’,/#!?$#%@^&*;:{}–—=_`~[\\]()0-9]/) // split the input based on any punctuation (except ' and -), line breaks, spaces, or numbers\r\n        .filter(word => word.length > 0) // strip out any empty 'words'\r\n    )\r\n\r\n    // flag that the data needs to be rebuilt\r\n    setStartersReady(false)\r\n    setTerminalsReady(false)\r\n    setDictionaryReady(false)\r\n  }, [input])\r\n\r\n  useEffect(() => {\r\n    // when the data is built, trigger generation\r\n    if (startersReady && terminalsReady && dictionaryReady) {\r\n      makeWords()\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [startersReady, terminalsReady, dictionaryReady])\r\n\r\n  // make a random choice, given options\r\n  const choose = (arr: string[]) => arr[Math.floor(arr.length * Math.random())]\r\n\r\n  const build = (): void => {\r\n    // if the input has changed,\r\n    if (!startersReady || !terminalsReady || !dictionaryReady) {\r\n      let newStart: string[] = []\r\n      let newTerm: Terminals = {}\r\n      let newDict: Dictionary = {}\r\n\r\n      // build the dictionary, terminals, and starters\r\n      for (let i = 0; i < text.length; i++) {\r\n        // grab the word and split it into an array of letters\r\n        const word = text[i].split('')\r\n\r\n        // add the word-initial letter pair to the list of possible starters\r\n        newStart.push(word.slice(0, 2).join(''))\r\n\r\n        // add the word-final letter pair to the list of possible terminals\r\n        newTerm[word.slice(-2).join('')] = true\r\n\r\n        // build the dictionary and stats\r\n        for (let j = 0; j < word.length - 1; j++) {\r\n          // add lookups for single letters\r\n          if (newDict.hasOwnProperty(word[j])) {\r\n            // if the letter is already in the dictionary, add its following letter\r\n            newDict[word[j]].push(word[j + 1])\r\n          } else {\r\n            // otherwise, add the letter and its following letter\r\n            newDict[word[j]] = [word[j + 1]]\r\n          }\r\n\r\n          // add lookups for paired letters after reaching the second letter\r\n          if (j > 0) {\r\n            if (newDict.hasOwnProperty(word[j - 1] + word[j])) {\r\n              // if the letter pair is already in the dictionary, add its following letter\r\n              newDict[word[j - 1] + word[j]].push(word[j + 1])\r\n            } else {\r\n              // otherwise, add the letter pair and its following letter\r\n              newDict[word[j - 1] + word[j]] = [word[j + 1]]\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      setStarters([...newStart])\r\n      setTerminals({ ...newTerm })\r\n      setDictionary({ ...newDict })\r\n    }\r\n\r\n    // trigger generation with useEffect\r\n    setStartersReady(true)\r\n    setTerminalsReady(true)\r\n    setDictionaryReady(true)\r\n  }\r\n\r\n  const generate = (min: number): string => {\r\n    // grab the last letter(s) of the word for lookup\r\n    const getLookup = (word: string[]) => {\r\n      return word.length < 2 ? word[word.length - 1] : word.slice(-2).join('')\r\n    }\r\n\r\n    // start with starter letters\r\n    let letter = choose(starters)\r\n    let next = letter.split('')\r\n    let word = next\r\n    let lookup = getLookup(word)\r\n\r\n    while (dictionary.hasOwnProperty(lookup)) {\r\n      // choose the next letter and add it to the word\r\n      next = dictionary[lookup]\r\n      letter = choose(next)\r\n      word.push(letter)\r\n      lookup = getLookup(word)\r\n\r\n      // if the word is long enough and the current letter is a terminal, end the loop\r\n      if (word.length >= min && terminals.hasOwnProperty(lookup)) {\r\n        break\r\n      }\r\n    }\r\n\r\n    // if the word isn't long enough, try again\r\n    if (word.length < min) {\r\n      return generate(min)\r\n    } else {\r\n      return word.join('')\r\n    }\r\n  }\r\n\r\n  const makeWords = (): void => {\r\n    if (!startersReady || !terminalsReady || !dictionaryReady) {\r\n      // if the data needs to be built, build it\r\n      build()\r\n    } else {\r\n      // if the data is built, generate the output\r\n      let results = []\r\n\r\n      // if the minimum length is greater than the maximum, display an error\r\n      if (min > max) {\r\n        results.push('Maximum length must be greater or equal to minimum length.')\r\n      } else if (text.length === 0) {\r\n        results.push('No input provided.')\r\n      } else if (starters.length === 0 || starters[0] === '') {\r\n        results.push('Internal error.')\r\n      } else {\r\n        // randomize the length of the words between the min and the max\r\n        for (let i = 0; i < num; i++) {\r\n          const length = min + Math.floor((max + 1 - min) * Math.random())\r\n          results.push(generate(length))\r\n        }\r\n      }\r\n\r\n      setOutput(results.join(' '))\r\n    }\r\n  }\r\n\r\n  return (\r\n    <main className={styles.main}>\r\n      <form className={styles.form}>\r\n        <textarea\r\n          id={styles.text}\r\n          className={styles.text}\r\n          name='text input'\r\n          placeholder='Enter as many words as you can. The more the better.'\r\n          value={input}\r\n          onChange={e => setInput(e.target.value)}\r\n        />\r\n        <div id={styles.options} className={styles.options}>\r\n          <label>\r\n            minimum length:{' '}\r\n            <input\r\n              id={styles.min}\r\n              className={styles.num}\r\n              name='minimum length'\r\n              type='number'\r\n              min='1'\r\n              max='10'\r\n              value={min}\r\n              onChange={e => setMin(+e.target.value)}\r\n            />\r\n          </label>\r\n          <label>\r\n            maximum length:{' '}\r\n            <input\r\n              id={styles.max}\r\n              className={styles.num}\r\n              name='maximum length'\r\n              type='number'\r\n              min='3'\r\n              max='20'\r\n              value={max}\r\n              onChange={e => setMax(+e.target.value)}\r\n            />\r\n          </label>\r\n          <label>\r\n            number of words:{' '}\r\n            <input\r\n              id={styles.num}\r\n              className={styles.num}\r\n              name='number of words'\r\n              type='number'\r\n              min='1'\r\n              max='9999'\r\n              value={num}\r\n              onChange={e => setNum(+e.target.value)}\r\n            />\r\n          </label>\r\n        </div>\r\n        <button\r\n          id={styles.generate}\r\n          className={styles.generate}\r\n          name='generate'\r\n          onClick={e => {\r\n            e.preventDefault()\r\n            makeWords()\r\n          }}\r\n        >\r\n          Generate\r\n        </button>\r\n      </form>\r\n      <Results results={output} />\r\n    </main>\r\n  )\r\n}\r\n\r\nexport default Form\r\n","import React from 'react'\r\n\r\nimport styles from './pageFooter.module.sass'\r\n\r\nconst Footer: React.FC = () => {\r\n  const years = (): string => {\r\n    const start = 2019\r\n    const current = new Date().getFullYear()\r\n    return current > start\r\n      ? `${start}–${current}`\r\n      : start.toString()\r\n  }\r\n  return (\r\n    <footer className={styles.footer}>\r\n      <p className={styles.copyright}>Built by <a href='https://github.com/nai888' target='_blank' rel='noopener noreferrer'>Ian A.&nbsp;Cook</a>, copyright © {years()} under the <a href='https://github.com/nai888/markov-words/blob/master/LICENSE' target='_blank' rel='noopener noreferrer'>AGPL-3.0 license</a>. See the project on <a href='https://github.com/nai888/markov-words' target='_blank' rel='noopener noreferrer'>GitHub</a>.</p>\r\n    </footer>\r\n  )\r\n}\r\n\r\nexport default Footer\r\n","import React from 'react'\n\nimport Header from './components/page-header'\nimport Form from './components/form'\nimport Footer from './components/page-footer'\n\nconst App: React.FC = () => {\n  return (\n    <>\n      <Header />\n      <Form />\n      <Footer />\n    </>\n  )\n}\n\nexport default App\n","const isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register (config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    )\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW (swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker (swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      )\n    })\n}\n\nexport function unregister () {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister()\n    })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport './global.sass'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\nserviceWorker.register()\n"],"sourceRoot":""}